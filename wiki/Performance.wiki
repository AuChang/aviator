#summary 性能测试
#labels Phase-Support,Featured
<wiki:toc max_depth="2" />
= Introduction =
这个测试本质上是不公平的，因为实现的机制完全不同，这里只是为了做一个直观的比较，让用户对Aviator的性能有个直观的感受。参与测试的包括Aviator、groovy和[http://commons.apache.org/jexl/ JEXL]。


= 硬件和软件 =

 * OS:              Linux dennis-laptop 2.6.38-8-generic-pae #42-Ubuntu SMP Mon Apr 11 05:17:09 UTC 2011 i686 i686 i386 GNU/Linux

 *  MemTotal:        4012044 kB

 * CPU:              Intel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz

 * JDK:              java version "1.6.0_18" Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) Server VM (build 16.0-b13, mixed mode)

 * Aviator :  2.0

 * Groovy:    1.8.0

 * JEXL :  2.0.1

= JVM启动参数 =

{{{
   -Xmx512m -XX:CompileThreshold=10000 -XX:MaxPermSize=128m
}}}


= 测试方法 =

三个引擎都采用预先编译再进行测试的方式，循环1000万次执行编译后的结果，测量耗时。

= test by yourself=

源码在 https://github.com/killme2008/EL-benchmark，你可以自己构建并测试。

= 场景1 =

计算算术表达式：
{{{
1000+100.0*99-(600-3*15)/(((68-9)-3)*2-100)+10000%7*71
}}}

测试结果：
|| 测试 || 耗时（单位: 毫秒）||
|| Aviator || 8        ||
|| Groovy  || 83472       ||
|| JEXL ||  62128  ||

结论： Aviator在计算常量算术表达式的时候是非常快速的，跟Groovy和IKExpression差距极大。这是因为aviator会在编译的时候直接计算出常量表达式的结果。

= 场景2 =

计算逻辑表达式和三元表达式混合：
{{{
6.7-100>39.6 ? 5==5? 4+5:6-1 : !(100%3-39.0<27) ? 8*2-199: 100%3
}}}

测试结果：
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 2        ||
|| Groovy  || 21914      ||
|| JEXL ||  39075  ||

结论： 跟上面一样，aviator仍然有极大优势，得益于编译时做的优化。

= 场景3 =

计算算术表达式和逻辑表达式的混合，带有5个变量的表达式：
{{{
i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99 ==i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99
}}}

变量设定为：
{{{
        int i = 100;
        float pi = 3.14f;
        double d = -3.9;
        byte b = (byte) 4;
        boolean bool=false;
}}}

每次执行前都重新设置这些变量的值。

结果：
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 26842        ||
|| Groovy  || 14611     ||
|| JEXL || 82121  ||

结论： Groovy表现最佳，Aviator跟它差距较小，JEXL最差。

= 场景4 =

表达式为：
{{{
pi*d+b-(1000-d*b/pi)/(pi+99-i*d)-i*pi*d/b
}}}
变量的设定值与场景3一致。

结果：
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 18802        ||
|| Groovy  || 11384     ||
|| JEXL || 41406  ||

结论也与场景3一致。aviator和groovy接近，而JEXL最差。

= 场景5:日期函数调用 =

 * Aviator执行 sysdate()
 * groovy执行   new java.util.Date()
 * JEXL执行 new("java.util.Date")

结果:
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 15514        ||
|| Groovy  || 15107     ||
|| JEXL ||  41406  ||

结论：Aviator和groovy最佳，JEXL仍然垫底。

= 场景6:字符串函数调用 =

 * Aviator执行 string.substring(s,b.d)
 * groovy执行  s.substring(b.d)
 * JEXL执行  s.substring(b.d)

其中变量设定为：
{{{
   s="hello world";
   b为map
   b.d=5;
}}}

结果:
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 7735        ||
|| Groovy  || 4074     ||
|| JEXL ||  17955  ||

结论：Groovy最佳，aviator其次，JEXL垫底。

= 场景6:字符串函数嵌套调用 =

 * Aviator执行 string.substring(string.substring(s,b.d),a,b.c.e)
 * groovy执行  s.substring(b.d).substring(a,b.c.e);
 * JEXL执行  s.substring(b.d).substring(a,b.c.e);

其中变量设定为：
{{{
   s="hello world";
   a=1
   b为map
   b.d=5;
   b.c为map
   b.c.e=3;
}}}

结果:
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 13607        ||
|| Groovy  || 5455     ||
|| JEXL ||  46302  ||

结论：Groovy最佳，aviator其次，JEXL与前两者差距较大。


= 场景7:测试编译性能 =

测试编译性能，编译表达式
{{{
i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99 ==i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99
}}}

循环编译1000次，因为groovy编译非常慢加上perm区大小限制，只能将次数限制。

结果：
|| 测试 || 耗时（单位:毫秒）||
|| Aviator || 1299       ||
|| Groovy  || 17940    ||
|| JEXL ||  418  ||

JEXL编译速度最快，aviator其次，而groovy反而最差。我估计是groovy编译的时候要做很多优化导致。

= 小结 =

 * Aviator在执行常量表达式的时候，性能最佳。常量越多的表达式，编译优化效果越好。
 * 带有变量表达式和函数调用上，groovy最佳，aviator接近groovy，而JEXL最差。
 * 编译性能上，JEXL最佳，aviator其次，而groovy最差。