#summary 用户指南 使用手册
<wiki:toc max_depth="4" />
= 简介 =

Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？

Aviator的设计目标是*轻量级*和*高性能 *，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才xxk；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。

其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式*编译成Java字节码*，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。

= 特性 =

Aviator的特性

 * 支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。

 * 支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$num指向匹配分组。

 * 自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。

 * 支持传入变量，支持类似a.b.c的嵌套变量访问。

 * 性能优秀

Aviator的限制：

 * 没有if else、do while等语句，没有赋值语句，仅支持逻辑表达式、算术表达式、三元表达式和正则匹配。

 * 不允许自定义函数

 * 没有位运算符

= 整体结构 =

Aviator的结构非常简单，一个典型的求值器的结构

[http://www.blogjava.net/images/blogjava_net/killme2008/aviator.jpg]


= 使用手册 =

== 执行表达式 ==


Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理，最简单的例子，执行一个计算1+2+3的表达式：
{{{

import com.googlecode.aviator.AviatorEvaluator;
public class SimpleExample {
    public static void main(String[] args) {
        Long result = (Long) AviatorEvaluator.execute("1+2+3");
        System.out.println(result);
    }
}

}}}

细心的朋友肯定注意到结果是Long，而不是Integer。这是因为Aviator的数值类型仅支持Long和Double，任何整数都将转换成Long，任何浮点数都将转换为Double，包括用户传入的变量数值。这个例子的打印结果将是正确答案6。

== 使用变量 ==

想让Aviator对你say hello吗？很简单，传入你的名字，让Aviator负责字符串的相加：
{{{
import com.googlecode.aviator.AviatorEvaluator;


public class SayHello {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.print("Usesage: Java SayHello yourname");
        }
        String yourname = args[0];
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("yourname", yourname);
        String result = (String) AviatorEvaluator.execute(" 'hello ' + yourname ", env);
        System.out.println(result);
    }
}
}}}

上面的例子演示了怎么向表达式传入变量值，表达式中的yourname是一个变量，默认为null，通过传入Map<String,Object>的变量绑定环境，将yourname设置为你输入的名称。env的key是变量名，value是变量的值。

上面例子中的'hello '是一个Aviator的String，Aviator的String是任何用单引号或者双引号括起来的字符序列，String可以比较大小（基于unicode顺序），可以参与正则匹配，可以与任何对象相加，任何对象与String相加结果为String。String中也可以有转义字符，如\n、\\、\'等。
{{{
AviatorEvaluator.execute(" 'a\"b' ");   //字符串 a'b
AviatorEvaluator.execute(" \"a\'b\" ");  //字符串 a"b
AviatorEvaluator.execute(" 'hello'+3 ");  //字符串 hello 3
AviatorEvaluator.execute(" 'hello '+ unknow ");  //字符串 hello null
}}}

== 编译表达式 ==

上面提到的例子都是直接执行表达式，事实上Aviator背后都帮你做了编译并执行的工作。你可以自己先编译表达式，返回一个编译的结果，然后传入不同的env来复用编译结果，提高性能，这是更推荐的使用方式：
{{{
import java.util.HashMap;
import java.util.Map;

import com.googlecode.aviator.AviatorEvaluator;
import com.googlecode.aviator.Expression;

public class CompileExample {
    public static void main(String[] args) {
        String expression = "a-(b-c)>100";
        // 编译表达式
        Expression compiledExp = AviatorEvaluator.compile(expression);

        Map<String, Object> env = new HashMap<String, Object>();
        env.put("a", 100.3);
        env.put("b", 45);
        env.put("c", -199.100);

        // 执行表达式
        Boolean result = (Boolean) compiledExp.execute(env);
        System.out.println(result);
    }
}

}}}

通过compile方法可以将表达式编译成Expression的中间对象，当要执行表达式的时候传入env并调用Expression的execute方法即可。表达式中使用了括号来强制优先级，这个例子还使用了>用于比较数值大小，比较运算符!=、==、>、>=、<、<=不仅可以用于数值，也可以用于String、Pattern、Boolean等等，甚至是任何用户传入的两个都实现了java.lang。Comparable接口的对象之间。

编译后的结果你可以自己缓存，也可以交给Aviator帮你缓存，AviatorEvaluator内部有一个全局的缓存池，如果你决定缓存编译结果，可以通过：
{{{
   public static Expression compile(String expression, boolean cached)
}}}
将cached设置为true即可，那么下次编译同一个表达式的时候将直接返回上一次编译的结果。使缓存失效通过：
{{{
public void invalidateCache(String expression)
}}}
方法。

== 三元操作符 ==
Aviator不提供if else语句，但是提供了三元操作符?:用于条件判断，使用上与java没有什么不同：
{{{
import java.util.HashMap;
import java.util.Map;

import com.googlecode.aviator.AviatorEvaluator;


public class TernaryOperatorExample {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.println("Usage: java TernaryOperatorExample [number]");
            System.exit(1);
        }
        int num = Integer.parseInt(args[0]);
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("a", num);
        String result = (String) AviatorEvaluator.execute("a>0? 'yes':'no'", env);
        System.out.println(result);
    }
}

}}}

这个例子用来判断用户传入的数字是否是正整数，是的话打印yes。

Aviator的三元表达式对于两个分支的结果类型并不要求一致，可以是任何类型，这一点与java不同。

== 正则表达式匹配 ==

Aviator支持类Ruby和Perl风格的表达式匹配运算，通过=~操作符，如下面这个例子匹配email并提取用户名返回：
{{{
import java.util.HashMap;
import java.util.Map;

import com.googlecode.aviator.AviatorEvaluator;

public class RegularExpressionExample {
    public static void main(String[] args) {
        String email = "killme2008@gmail.com";
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("email", email);
        String username = (String) AviatorEvaluator.execute("email=~/([\\w0-8]+@\\w+[\\.\\w+]+)/ ? $1:'unknow'", env);
        System.out.println(username);
    }
}
}}}

email与正则表达式//([\\w0-8]+@\\w+[\\.\\w+]+)/通过=~操作符来匹配，结果为一个Boolean类型，因此可以用于三元表达式判断，匹配成功的时候返回$1，指代正则表达式的分组1，也就是用户名，否则返回unknown。这个例子将打印killme2008这个用户名。

Aviator在表达式级别支持正则表达式，通过//括起来的字符序列构成一个正则表达式，正则表达式可以用于匹配（作为=~的右操作数)、比较大小，匹配仅能与字符串进行匹配。匹配成功后，Aviator会自动将匹配成功的分组放入$num的变量中，其中$0指代整个匹配的字符串，而$1表示第一个分组，以此类推。

Aviator的正则表达式规则跟Java完全一样，因为内部其实就是使用java.util.regex.Pattern做编译的。

== 变量的语法糖衣 ==

Aviator有个方便用户使用变量的语法糖衣，当你要访问变量a中的某个属性b，那么你可以通过a.b访问到，更进一步，a.b.c将访问变量a的b属性中的c属性值，推广开来也就是说Aviator可以将变量声明为嵌套访问的形式，一个例子，Foo类有属性i、f、date：
{{{
 public class Foo {
        int i;
        float f;
        Date date = new Date();

        public Foo(int i, float f, Date date) {
            super();
            this.i = i;
            this.f = f;
            this.date = date;
        }

        public int getI() {
            return i;
        }

        public void setI(int i) {
            this.i = i;
        }

        public float getF() {
            return f;
        }

        public void setF(float f) {
            this.f = f;
        }

        public Date getDate() {
            return date;
        }

        public void setDate(Date date) {
            this.date = date;
        }
    }
}}}

Foo类符合JavaBean规范，并且是public的，我们执行一个表达式来描述Foo:

{{{
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.googlecode.aviator.AviatorEvaluator;

public class VariableExample {
    public static void main(String[] args) {
        Foo foo = new Foo(100, 3.14f, new Date());
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("foo", foo);

        String result =
                (String) AviatorEvaluator.execute(
                    " '[foo i='+ foo.i + ' f='+foo.f+' year='+(foo.date.year+1900)+ ' month='+foo.date.month +']' ",
                    env);
        System.out.println(result);

    }
}
}}}

细看下表达式：

{{{
'[foo i='+ foo.i + ' f='+foo.f+' year='+(foo.date.year+1900)+ ' month='+foo.date.month +']'
}}}

可以看到我们通过foo.i和foo.f的方式来访问foo变量中的i和f属性，并且通过foo.date.year的方式来访问foo中date对象的year属性（其实是getYear方法）。

== nil对象 ==

nil是Aviator内置的常量，类似java中的null，表示空的值。nil跟null不同的在于，在java中null只能使用在==、!=的比较运算符，而nil还可以使用>、>=、<、<=等比较运算符。Aviator规定，任何对象都比nil大除了nil本身。用户传入的变量如果为null，将自动以nil替代。

{{{
        AviatorEvaluator.execute("nil == nil");  //true
        AviatorEvaluator.execute(" 3> nil");    //true
        AviatorEvaluator.execute(" true!= nil");    //true
        AviatorEvaluator.execute(" ' '>nil ");  //true
        AviatorEvaluator.execute(" a==nil ");   //true,a is null
}}}

nil与String相加的时候，跟java一样显示为null

== 日期比较 ==

Aviator并不支持日期类型，如果要比较日期，你需要将日期写字符串的形式，并且要求是形如"yyyy-MM-dd HH:mm:ss:SS"的字符串，否则都将报错。 字符串跟java.util.Date比较的时候将自动转换为Date对象进行比较：

{{{
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.googlecode.aviator.AviatorEvaluator;


public class DateExample {
    public static void main(String[] args) throws Exception {
        Map<String, Object> env = new HashMap<String, Object>();
        final Date date = new Date();
        String dateStr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS").format(date);
        env.put("date", date);
        env.put("dateStr", dateStr);

        Boolean result = (Boolean) AviatorEvaluator.execute("date==dateStr", env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date > '2009-12-20 00:00:00:00' ", env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date < '2200-12-20 00:00:00:00' ", env);
        System.out.println(result);

        result = (Boolean) AviatorEvaluator.execute("date ==date ", env);
        System.out.println(result);
    }

}

}}}

也就是说String除了能跟String比较之外，还能跟nil和date字符串比较。


== 语法手册 ==

下面是Aviator详细的语法规则定义。

=== 数据类型 ===

 * Number类型：数字类型，支持两种类型，分别对应Java的Long和Double，也就是说任何整数都将被转换为Long，而任何浮点数都将被转换为Double，包括用户传入的数值也是如此转换。不支持科学计数法，仅支持十进制。如-1、100、2.3等。

 * String类型：  字符串类型，单引号或者双引号括起来的文本串，如'hello world'，变量如果传入的是String或者Character也将转为String类型。

 * Bool类型：    常量true和false，表示真值和假值，与java的Boolean.TRUE和Boolean.False对应。

 * Pattern类型： 类似Ruby、perl的正则表达式，以//括起来的字符串，如/\d+/，内部实现为java.util.Pattern。

 * 变量类型：   与Java的变量命名规则相同，变量的值由用户传入，如"a"、"_b"等

 * nil类型:     常量nil,类似java中的null，但是nil比较特殊，nil不仅可以参与==、!=的比较，也可以参与>、>=、<、<=的比较，Aviator规定任何类型都n大于nil除了nil本身，nil==nil返回true。用户传入的变量值如果为null，那么也将作为nil处理，nil打印为null。

=== 操作符 ===

==== 算术运算符 ====

Aviator支持常见的算术运算符，包括"+"  "-" "*" "/" "%" 五个二元运算符，和一元运算符"-"。其中 "-" "*" "/" "%"和一元的"-"仅能作用于Number类型。

"+"不仅能用于Number类型，还可以用于String的相加，或者字符串与其他对象的相加。Aviator规定，任何类型与String相加，结果为String。

=== 逻辑运算符 ===

Avaitor的支持的逻辑运算符包括，一元否定运算符"!"，以及逻辑与的"&&"，逻辑或的"||"。逻辑运算符的操作数只能为Boolean。

=== 关系运算符 ===

Aviator支持的关系运算符包括"<"  "<="  ">"  ">="  以及"=="和"!=" 。

关系运算符可以作用于Number之间、String之间、Pattern之间、Boolean之间、变量之间以及其他类型与nil之间的关系比较，不同类型除了nil之外不能相互比较。

Aviator规定任何对象都比nil大除了nil之外。

=== 匹配运算符 ===

匹配运算符"=~"用于String和Pattern的匹配，它的左操作数必须为String，右操作数必须为Pattern。匹配成功后，Pattern的分组将存于变量$num，num为分组索引。

=== 三元运算符 ===

Aviator没有提供if else语句，但是提供了三元运算符 "?:"，形式为 bool ? exp1: exp2。
其中bool必须为结果为Boolean类型的表达式，而exp1和exp2可以为任何合法的Aviator表达式，并且不要求exp1和exp2返回的结果类型一致。

=== 操作符优先级列表 ===
Aviator支持操作符的优先级，并且允许通过括号来强制优先级：








