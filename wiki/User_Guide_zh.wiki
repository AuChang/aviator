#summary 用户指南 使用手册
<wiki:toc max_depth="4" />
= 简介 =

Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？

Aviator的设计目标是*轻量级*和*高性能 *，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才xxk；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。

其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式*编译成Java字节码*，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。

= 特性 =

Aviator的特性

 * 支持大部分运算操作符，包括算术操作符、逻辑操作符、正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。

 * 支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$num指向匹配分组。

 * 自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。

 * 支持传入变量，支持类似a.b.c的嵌套变量访问。

 * 性能优秀

Aviator的限制：

 * 没有if else、do while等语句，仅支持逻辑表达式、算术表达式、三元表达式和正则匹配。

 * 不允许自定义函数

 * 不允许赋值语句

= 整体结构 =

Aviator的结构非常简单，一个典型的求值器的结构

[http://www.blogjava.net/images/blogjava_net/killme2008/aviator.jpg]


= 使用手册 =

== 执行表达式 ==


Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理，最简单的例子，执行一个计算1+2+3的表达式：
{{{

import com.googlecode.aviator.AviatorEvaluator;
public class SimpleExample {
    public static void main(String[] args) {
        Long result = (Long) AviatorEvaluator.execute("1+2+3");
        System.out.println(result);
    }
}

}}}

细心的朋友肯定注意到结果是Long，而不是Integer。这是因为Aviator的数值类型仅支持Long和Double，任何整数都将转换成Long，任何浮点数都将转换为Double，包括用户传入的变量数值。这个例子的打印结果将是正确答案6。

== 使用变量 ==

想让Aviator对你say hello吗？很简单，传入你的名字，让Aviator负责字符串的相加：
{{{
import com.googlecode.aviator.AviatorEvaluator;


public class SayHello {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.print("Usesage: Java SayHello yourname");
        }
        String yourname = args[0];
        Map<String, Object> env = new HashMap<String, Object>();
        env.put("yourname", yourname);
        String result = (String) AviatorEvaluator.execute(" 'hello ' + yourname ", env);
        System.out.println(result);
    }
}
}}}

上面的例子演示了怎么向表达式传入变量值，表达式中的yourname是一个变量，默认为null，通过传入Map<String,Object>的变量绑定环境，将yourname设置为你输入的名称。env的key是变量名，value是变量的值。

上面例子中的'hello '是一个Aviator的String，Aviator的String是任何用单引号或者双引号括起来的字符序列，String可以比较大小（基于unicode顺序），可以参与正则匹配，可以与任何对象相加，任何对象与String相加结果为String。String中也可以有转义字符，如\n、\\、\'等。
{{{
AviatorEvaluator.execute(" 'a\"b' ");   //字符串 a'b
AviatorEvaluator.execute(" \"a\'b\" ");  //字符串 a"b
AviatorEvaluator.execute(" 'hello'+3 ");  //字符串 hello 3
AviatorEvaluator.execute(" 'hello '+ unknow ");  //字符串 hello null
}}}

=== 编译表达式 ===

上面提到的例子都是直接执行表达式，事实上Aviator背后都帮你做了编译并执行的工作。你可以自己先编译表达式，返回一个编译的结果，然后传入不同的env来复用编译结果，提高性能
{{{
  
}}}














== 语法手册 ==

=== 数据类型 ===

 * Number类型：数字类型，支持两种类型，分别对应Java的Long和Double，也就是说任何整数都将被转换为Long，而任何浮点数都将被转换为Double，包括用户传入的数值也是如此转换。不支持科学计数法，仅支持十进制。如-1、100、2.3等。

 * String类型：  字符串类型，单引号或者双引号括起来的文本串，如'hello world' 

 * Bool类型：    常量true和false，表示真值和假值

 * Pattern类型： 类似Ruby、perl的正则表达式，以//括起来的字符串，如/\d+/

 * 变量类型：   与Java的变量命名规则相同，变量的值由用户传入，如"a"、"_b"等

 * nil类型:     常量nil,类似java中的null，但是nil比较特殊，nil不仅可以参与==、!=的比较，也可以参与>、>=、<、<=的比较，Aviator规定任何类型都n大于nil除了nil本身，nil==nil返回true。用户传入的变量值如果为null，那么也将作为nil处理。

=== 操作符 ===

==== 算术运算符 ====

Aviator支持常见的算术运算符，包括+  - * / % 五个二元运算符，和一元运算符"-"。
